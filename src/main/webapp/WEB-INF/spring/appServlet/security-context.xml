<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:security="http://www.springframework.org/schema/security"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context 
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/security 
                           http://www.springframework.org/schema/security/spring-security.xsd">
	<!-- 1단계 인증과 권한 처리 (in-memory) 방식으로 사용자를 만들고 권한 설정 그리고 스프링이 제공한 처리 과정 >> 
		auto-config="true" >> login 처리 자동화 -> 3.x.x >> access="ROLE_USER" -> 4.x.x 
		>> access=hasRole("ROLE_USER") -->
	<!-- 1단계 <security:http auto-config="true"> <security:csrf disabled="true" 
		/> <security:intercept-url pattern="/customer/noticeDetail.htm" access="hasRole('ROLE_USER')" 
		/> <security:intercept-url pattern="/customer/noticeReg.htm" access="hasRole('ROLE_ADMIN')" 
		/> </security:http> <security:authentication-manager> <security:authentication-provider> 
		<security:user-service> <security:user name="hong" password="1004" authorities="ROLE_USER"/> 
		<security:user name="admin" password="1004" authorities="ROLE_ADMIN,ROLE_USER"/> 
		</security:user-service> </security:authentication-provider> </security:authentication-manager> 
		</beans> -->
	<!-- 1단계 : 로그인 페이지 제공 <form name='f' action='/SpringMVC_Basic03_Sts_Mybatis_Security/login' 
		method='POST'> <input type='text' name='username' value=''> <input type='password' 
		name='password' /> </form> 1. 요청 주소 : /login >> 요청 >> controller 동작 >> id 
		, pwd 검증 권한 확인 >> session >> 페이지 /logout >> 처리 /login?error >> 에러 처리 -->
	<!-- 2단계 처리하기 login 페이지 처리 >>form-login 속성 정의하기 login-page : login form 
		페이지 URL username-parameter : form id의 name 속성값 (email >> id) password-parameter 
		: form pw의 name 속성값 login-processing-url : form action 값 (security를 이용해 인증처리) 
		default-target-url : 로그인 성공 시 이동 URL authentication-failure-url : 로그인 실패 
		시 이동 URL always-use-default-target : true 로 하면 무조건 default-target-url 로 이동한다. 
		false 로 하면 authentication-success-handler 대로 redirect 된다. authentication-success-handler-ref 
		: 로그인 성공 시 프로세스 정의, bean id 입력 만약 최종 로그인일시를 DB에 기록해야한다면 handler로 처리하는게 좋겠다. 
		res.sendRedirect 등으로 처리 authentication-failure-handler-ref : 로그인 실패 시 프로세스 
		정의, bean id 입력 >> security:logout logout-url : 로그아웃 처리할 URL (security가 알아서 
		만들기 때문에, 이 경로로 요청만 하면된다) logout-success-url : 로그아웃 성공 시 이동 URL success-handler-ref 
		: 로그아웃 성공 시 프로세스 정의, bean id 입력 invalidate-session : 로그아웃 시 세션 삭제여부 >>session-management 
		invalid-session-url : invalid session(세션 타임아웃 등) 일 때 이동 URL max-sessions 
		: 최대 허용 가능한 세션 수 expired-url : 중복 로그인 발생시 이동 URL (처음 접속한 세션이 invalidate가 
		되고 다음 요청시 invalid-session-url로 이동) error-if-maximum-exceeded : max-sessions을 
		넘었을때 접속한 세션을 실패처리할지 여부 (expired-url와 얘중에 하나만 쓰면 될듯) 아래 처리 한다고 해서 login 처리 
		직접 하는 것은 아니다 ** /login 요청 처리는 여전이 spring 위임하고 있다 ..... 기본적인 요청 주소 , parametre 
		값은 정해진 되로 -->
	<!-- 2단계 <security:http> <security:csrf disabled="true" /> <security:form-login 
		login-page="/joinus/login.htm" authentication-failure-url="/joinus/login.htm?error" 
		/> <security:logout logout-success-url="/index.htm" /> <security:intercept-url 
		pattern="/customer/noticeDetail.htm" access="hasRole('ROLE_USER')" /> <security:intercept-url 
		pattern="/customer/noticeReg.htm" access="hasRole('ROLE_ADMIN')" /> </security:http> 
		<security:authentication-manager> <security:authentication-provider> <security:user-service> 
		<security:user name="hong" password="1004" authorities="ROLE_USER"/> <security:user 
		name="admin" password="1004" authorities="ROLE_ADMIN,ROLE_USER"/> </security:user-service> 
		</security:authentication-provider> </security:authentication-manager> -->
	<!-- 3단계 : JDBC사용한 DB연결 -->
	<security:http>
		<security:csrf disabled="true"/>
		<security:form-login username-parameter="user_email"
    						 password-parameter="user_pwd"
							 login-page="/login"
							 authentication-success-handler-ref="loginSuccessHandler"
							 authentication-failure-handler-ref="loginFailureHandler"/>
							 
		<security:logout 	logout-url="/logout"
							logout-success-url="/main"/>
		<security:intercept-url pattern="/profileEditAssociate" access="hasRole('ROLE_ASSOCIATE_USER')" />
		<security:intercept-url pattern="/myProfile*" access="hasRole('ROLE_ASSOCIATE_USER')" />
		<security:intercept-url pattern="/my*" access="hasRole('ROLE_REGULAR_USER')" />
		<security:intercept-url pattern="/free*" access="hasRole('ROLE_REGULAR_USER')" />
		<security:intercept-url pattern="/routineBrd*" access="hasRole('ROLE_REGULAR_USER')" />
  		<security:intercept-url pattern="/admin/**" access="hasRole('ROLE_ADMIN')" />
	
		<security:session-management invalid-session-url="/login">
	        <security:concurrency-control max-sessions="1" expired-url="/login"/>
	        <!-- 
	        중복 로그인 방지. 만약 두번째 로그인을 막고 싶을 경우 error-if-maximum0exceeded="true"를 추가하여 
	        값이 true일 때 두번째 로그인을 막는다. -->
	    </security:session-management>
	</security:http>
	<security:authentication-manager>
		<security:authentication-provider>
			
		 <security:jdbc-user-service data-source-ref="driverManagerDataSource"
	   								 users-by-username-query="SELECT user_email, user_pwd, enabled FROM User where user_email=? and user_grade='regular'" 
	   								 authorities-by-username-query="select u.user_email , r.ROLE_NAME  
	   								 								from User u join Role r on u.user_email = r.user_email
	   								 								where u.user_email=?" />
		<!-- 추가된 부분임 -->
		<security:password-encoder ref="bCryptPasswordEncoder"/>
		</security:authentication-provider>
	</security:authentication-manager>
	<bean id="loginSuccessHandler" class="kr.or.bodiary.interceptor.LoginSuccessHandler">
	    <property name="loginEmail" value="user_email"/>
	    <property name="defaultUrl" value="/main"/>
	    <property name="associateUrl" value="/profileEditAssociate"/>
	</bean>
	<bean id="loginFailureHandler" class="kr.or.bodiary.interceptor.LoginFailureHandler">
	    <property name="loginEmail" value="loginId"/>
	    <property name="loginPwd" value="loginPwd"/>
	    <property name="errormsgname" value="ERRORMSG"/>
	    <property name="defaultFailureUrl" value="/login?error"/>
	</bean>
	<context:component-scan base-package="kr.or.bodiary.interceptor"/>
</beans>  


